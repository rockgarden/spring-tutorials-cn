# [Java中的递归](https://www.baeldung.com/java-recursion)

1. 简介

    在这篇文章中，我们将重点讨论任何编程语言中的一个核心概念--递归(recursive)。

    我们将解释递归函数的特点，并展示如何使用递归来解决Java中的各种问题。

2. 理解递归

    1. 定义

        在Java中，函数调用机制支持让一个方法调用自己的可能性。这种功能被称为递归。

        例如，假设我们要对从0到某个数值n的整数进行求和。

        ```java
        public int sum(int n) {
            if (n >= 1) {
                return sum(n - 1) + n;
            }
            return n;
        }
        ```

        递归函数有两个主要要求。

        - 一个停止条件--当某个条件得到满足时，函数返回一个值，而不需要进一步的递归调用
        - 递归调用--函数用一个离停止条件更近一步的输入来调用自己
        每一次递归调用都会在JVM的堆栈内存中增加一个新的框架。因此，如果我们不注意我们的递归调用可以潜入多深，可能会发生内存不足的异常。

        这个潜在的问题可以通过利用尾部递归优化(tail-recursion)来避免。

    2. 尾部递归与头部递归的比较

        当递归调用是该函数执行的最后一件事时，我们把递归函数称为尾部递归(Tail Recursion)。否则，它就被称为头部递归(Head Recursion)。

        我们上面的sum()函数的实现是头部递归的一个例子，可以改为尾部递归。

        ```java
        public int tailSum(int currentSum, int n) {
            if (n <= 1) {
                return currentSum + n;
            }
            return tailSum(currentSum + n, n - 1);
        }
        ```

        在尾部递归中，递归调用是方法的最后一件事，所以在当前函数中没有任何东西可以执行。

        因此，从逻辑上讲，不需要存储当前函数的堆栈框架。

        尽管编译器可以利用这一点来优化内存，但需要注意的是，Java编译器暂时没有对尾部递归进行优化。

    3. 递归与迭代

        递归可以帮助简化一些复杂问题的实现，使代码更清晰、更易读。

        但是正如我们已经看到的，递归方法往往需要更多的内存，因为每次递归调用所需的堆栈内存都会增加。

        作为一种选择，如果我们可以用递归来解决一个问题，我们也可以用迭代(Iteration)来解决它。

        例如，我们的求和方法就可以用迭代来实现。

        ```java
        public int iterativeSum(int n) {
            int sum = 0;
            if(n < 0) {
                return -1;
            }
            for(int i=0; i<=n; i++) {
                sum += i;
            }
            return sum;
        }
        ```

        与递归相比，迭代方法有可能带来更好的性能。也就是说，与递归相比，迭代会更复杂，更难理解，例如：遍历二叉树(traversing a binary tree)。

        在头部递归、尾部递归和迭代方法之间做出正确的选择，都取决于具体问题和情况。

3. 例子

    现在，让我们试着用递归的方式解决一些问题。

    1. 寻找10的N次方

        假设我们需要计算10的N次方。以递归的方式思考，我们可以先计算10的(n-1)次方，然后将结果乘以10。

        然后，计算10的(n-1)-次方，将是10的(n-2)-次方，并将结果乘以10，如此类推。我们将继续这样做，直到我们需要计算10的（n-n）次方，也就是1。

        RecursionExample.powerOf10(int n)

    2. 寻找斐波那契数列的N-Th元素

        从0和1开始，斐波那契数列(Fibonacci Sequence)是一个数字序列，每个数字都被定义为它前面两个数字的总和。0 1 1 2 3 5 8 13 21 34 55 ...

        因此，给定一个数字n，我们的问题是找到斐波那契数列的第n个元素。为了实现递归解决方案，我们需要弄清楚停止条件和递归调用。

        幸运的是，这其实是很简单的。

        让我们称f(n)为序列的第n个值。然后我们将有f(n)=f(n-1)+f(n-2)（递归调用）。

        同时，f(0)=0，f(1)=1（停止条件）。

        那么，对我们来说，定义一个递归方法来解决这个问题真的很明显。

        RecursionExample.fibonacci(int n)

    3. 从十进制到二进制的转换

        现在，让我们考虑将一个十进制数转换为二进制数的问题。我们的要求是实现一个接收正整数值n并返回二进制字符串表示的方法。

        将十进制数转换为二进制的一种方法是将该值除以2，记录余数，然后继续除以2的商。

        我们一直这样除下去，直到得到一个0的商。然后，通过按保留顺序写出所有的余数，我们得到二进制字符串。

        因此，我们的问题是写一个方法，按保留顺序返回这些余数。

        RecursionExample.toBinary(int n)

    4. 二叉树的高度

        二叉树的高度被定义为从根到最深的叶子的边的数量。我们现在的问题是为一个给定的二叉树计算这个值。

        一个简单的方法是找到最深的叶子，然后计算根和该叶子之间的边。

        但是，为了考虑一个递归的解决方案，我们可以把二叉树的高度定义重述为根的左分支和根的右分支的最大高度，再加上1。

        如果根没有左分支和右分支，其高度为零。

        下面是我们的实现。

        RecursionExample.calculateTreeHeight(BinaryNode root)

        因此，我们看到，有些问题可以用递归的方式来解决，非常简单。
