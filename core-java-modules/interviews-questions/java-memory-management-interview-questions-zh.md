# Java基础

- Java 集合面试问题
- Java 类型系统面试问题
- Java 并发面试问题（+ 答案）
- Java 类结构和初始化面试问题
- Java 8 面试问题（+ 答案）
- [x] [Java 中的内存管理面试问题](#java中的内存管理面试问题)
- Java 生成面试问题（+ 答案）
- Java 流量控制面试问题（+ 答案）
- Java 异常面试问题（+ 答案）
- Java 注解面试问题（+ 答案）
- 热门 Spring Framework 面试问题

## Java中的内存管理面试问题

1. 简介

    本文将探讨 Java 开发人员面试中经常出现的一些内存管理问题。内存管理是一个并不为很多开发人员所熟悉的领域。

    事实上，开发人员一般不需要直接处理这个概念--因为 JVM 会处理这些琐碎的细节。除非出了大问题，否则即使是经验丰富的开发人员也不一定能随时掌握内存管理的准确信息。

    另一方面，这些概念在面试中其实很常见，所以我们还是直接进入正题吧。

2. 问题

    Q1. "Java 中的内存管理" 是什么意思？

    内存是应用程序有效运行所需的关键资源，与其他资源一样，内存是稀缺的。因此，在应用程序或应用程序的不同部分之间分配和取消分配内存需要非常小心和谨慎。

    但是，在 Java 中，开发人员不需要明确地分配和取消分配内存，JVM（更具体地说是垃圾回收器）负责处理内存分配，因此开发人员不需要这样做。

    这与 C 语言的情况相反，在 C 语言中，程序员可以直接访问内存，并在代码中引用内存单元，这就为内存泄漏创造了很大的空间。

    Q2. 什么是垃圾回收及其优势？

    垃圾回收是指查看堆内存，识别哪些对象在使用，哪些不在使用，并删除未使用对象的过程。

    使用中的对象或引用对象，意味着程序的某些部分仍保留着指向该对象的指针。未使用对象或未引用对象不再被程序的任何部分引用。因此，未引用对象使用的内存可以被回收。

    垃圾回收的最大优势在于，它免除了我们手动分配/删除内存的负担，使我们可以集中精力解决手头的问题。

    Q3. 垃圾回收有什么缺点吗？

    有。每当垃圾回收器运行时，它都会影响应用程序的性能。这是因为应用程序中的所有其他线程都必须停止运行，以便垃圾回收器线程有效完成工作。

    根据应用程序的要求，这可能是客户无法接受的实际问题。不过，通过巧妙的优化、垃圾回收器调整和使用不同的 GC 算法，可以大大减少甚至消除这个问题。

    Q4. Stop-The-World 一词的含义是什么？

    当垃圾收集器线程运行时，其他线程会停止，这意味着应用程序会暂时停止。这类似于房屋大扫除或熏蒸，在进程完成之前，住户不得进入。

    根据应用程序的需要，"让世界停止" 垃圾回收可能会导致不可接受的冻结。这就是为什么必须对垃圾收集器进行调整和 JVM 优化，以使遇到的冻结至少是可接受的。

    Q5. 什么是堆栈（Stack）和堆（Heap）？这些内存结构中分别存储了什么内容，它们之间有何关联？

    堆栈是内存的一部分，它包含嵌套方法调用直至程序当前位置的信息。它还包含当前执行方法中定义的所有局部变量和对堆上对象的引用。

    这种结构允许运行时从方法中返回时知道它被调用的地址，并在退出方法后清除所有局部变量。每个线程都有自己的堆栈。

    堆是用于分配对象的大容量内存。使用 new 关键字创建对象时，该对象会被分配到堆上。但是，该对象的引用却存在于堆栈中。

    Q6. 什么是代际垃圾回收，是什么使它成为一种流行的垃圾回收方法？

    代际垃圾收集(Generational garbage collection)可以宽泛地定义为垃圾收集器使用的策略，即把堆划分为若干称为 "代" 的部分，每个部分将根据对象在堆上的 "年龄" 来存放它们。

    每当垃圾收集器运行时，其第一步称为标记。垃圾回收器在此过程中会识别哪些内存正在使用，哪些没有使用。如果必须扫描系统中的所有对象，这可能是一个非常耗时的过程。

    随着分配的对象越来越多，对象列表也会越来越大，导致垃圾回收时间越来越长。然而，对应用程序的经验分析表明，大多数对象的寿命都很短。

    在代际垃圾收集中，对象会根据其 "年龄"（即已存活的垃圾收集周期）进行分组。这样，大部分工作就可以分散到不同的次要和主要分区中。

    如今，几乎所有的垃圾收集器都是一代式的。这种策略之所以如此流行，是因为随着时间的推移，它已被证明是最佳解决方案。

    Q7. 详细说明代际垃圾回收的工作原理

    要正确理解代际垃圾收集的工作原理，首先要记住 Java 堆是如何结构化以方便代际垃圾收集的。

    堆被划分为更小的空间或代。这些空间分别是年轻一代、老一代或长期一代，以及永久一代。

    年轻一代承载了大部分新创建的对象。对大多数应用程序的经验研究表明，大多数对象的寿命都很短，因此很快就会被收集。因此，新对象从这里开始其旅程，只有在达到一定 "年龄" 后才会 "晋升" 到旧一代空间。

    代际垃圾收集中的 "年龄" 一词指的是对象已存活的收集周期数。

    年轻一代空间又分为三个空间：一个伊甸园空间和两个幸存者空间，如幸存者 1（s1）和幸存者 2（s2）。

    老一代空间容纳在内存中存活时间超过一定 "年龄" 的对象。从年轻一代垃圾回收中存活下来的对象会被提升到这个空间。它一般比年轻代大。由于空间更大，垃圾回收的成本更高，频率也比年轻代低。

    永久代（通常称为 PermGen）包含 JVM 描述应用程序中使用的类和方法所需的元数据。它还包含用于存储内部字符串的字符串池。运行时，JVM 会根据应用程序使用的类对其进行填充。此外，平台库的类和方法也可以存储在这里。

    首先，任何新对象都会分配到 Eden 空间。两个生存空间一开始都是空的。当伊甸园空间填满时，会触发一次小规模的垃圾回收。被引用的对象会被转移到第一个生存者空间。未被引用的对象会被删除。

    在下一次小规模垃圾回收期间，伊甸园空间也会发生同样的情况。未引用的对象被删除，引用的对象被移动到生存者空间。不过，在这种情况下，它们会被移动到第二个生存空间（S2）。

    此外，第一个生存空间（S1）中最后一个次要 GC 的对象的年龄也会增加，并被移动到 S2。一旦所有存活对象都被移到 S2，S1 和 Eden 空间都会被清空。此时，S2 包含不同年龄的对象。

    在下一次小 GC 中，重复同样的过程。不过，这次存活空间会发生切换。引用对象从 Eden 和 S2 移到 S1。存活对象被老化。伊甸园和 S2 被清除。

    在每个小的垃圾回收周期后，都会检查每个对象的年龄。达到某个任意年龄（例如 8 岁）的对象会从年轻一代升级到老一代或终身一代。在随后的所有次要垃圾回收周期中，对象将继续被提升到旧一代空间。

    这几乎耗尽了年轻一代的垃圾收集过程。最后，将对老一代空间执行一次大的垃圾回收，清理并压缩该空间。每次大垃圾回收都会有若干次小垃圾回收。

    Q8. 对象何时有资格进行垃圾回收？说明 GC 如何收集符合条件的对象？

    如果任何实时线程或静态引用都无法访问某个对象，那么该对象就符合垃圾回收或 GC 的条件。

    符合垃圾回收条件的对象最简单的情况是其所有引用都为空。没有任何实时外部引用的循环依赖关系也符合垃圾回收条件。因此，如果对象 A 引用了对象 B，而对象 B 引用了对象 A，并且它们没有任何其他有效引用，那么对象 A 和对象 B 都将符合垃圾回收条件。

    另一种明显的情况是父对象被设置为空。当一个厨房对象内部引用了一个冰箱对象和一个水槽对象，而厨房对象被设置为空时，冰箱和水槽都将与它们的父对象厨房一起被垃圾回收。

    Q9. 如何从 Java 代码触发垃圾回收？

    作为 Java 程序员，您不能在 Java 中强制进行垃圾回收；只有当 JVM 根据 Java 堆的大小认为需要进行垃圾回收时，才会触发垃圾回收。

    在从内存中删除对象之前，垃圾回收线程会调用该对象的 finalize()方法，并提供机会执行任何必要的清理。您也可以调用对象代码中的该方法，但并不能保证调用该方法时会进行垃圾回收。

    此外，System.gc() 和 Runtime.gc() 等方法用于向 JVM 发送垃圾回收请求，但不能保证垃圾回收会发生。

    Q10. 当没有足够的堆空间来存储新对象时会发生什么情况？

    如果堆（Heap）中没有内存空间来创建新对象，Java 虚拟机就会抛出 OutOfMemoryError（内存不足错误），或者更具体地说，抛出 java.lang.OutOfMemoryError 堆空间错误。

    Q11. 有可能 "复活" 已符合垃圾回收条件的对象吗？

    当对象符合垃圾回收条件时，GC 必须对其运行 finalize 方法。finalize 方法保证只运行一次，因此 GC 会将该对象标记为已终结，并让它休息到下一个周期。

    在 finalize 方法中，从技术上讲，你可以 "复活" 一个对象，例如，把它赋值给一个静态字段。该对象将再次成为有生命的对象，没有资格被垃圾回收，因此 GC 不会在下一个循环中回收它。

    不过，该对象将被标记为最终完成，因此当它再次符合条件时，finalize 方法将不会被调用。从本质上讲，在对象的生命周期内，你只能使用一次这种 "复活" 技巧。请注意，只有当你真正知道自己在做什么时，才可以使用这种丑陋的 "小把戏"--不过，了解了这种 "小把戏"，你就能对 GC 的工作原理有一定的了解。

    Q12. 描述强引用、弱引用、软引用和幽灵引用及其在垃圾回收中的作用。

    与 Java 中的内存管理一样，在关键应用程序中，工程师可能需要进行尽可能多的优化，以最大限度地减少延迟和提高吞吐量。虽然无法明确控制 JVM 中何时触发垃圾回收，但可以影响我们创建的对象如何进行垃圾回收。

    Java 为我们提供了引用对象来控制我们创建的对象与垃圾回收器之间的关系。

    默认情况下，我们在 Java 程序中创建的每个对象都会被一个变量强引用(strong reference)：

    `StringBuilder sb = new StringBuilder();`

    在上述代码段中，new 关键字创建了一个新的 StringBuilder 对象并将其存储在堆上。然后，变量 sb 存储了对该对象的强引用。这对垃圾收集器来说意味着，由于 sb 持有对特定 StringBuilder 对象的强引用，该对象根本没有资格被收集。只有当我们像下面这样使 sb 变为 null 时，情况才会发生变化：

    `sb = null;`

    调用上述命令行后，对象就有资格被收集了。

    我们可以通过显式地将对象封装到另一个引用对象中来改变对象与垃圾回收器之间的这种关系，该引用对象位于 java.lang.ref 包中。

    可以像这样为上述对象创建一个软引用(soft reference)：

    ```java
    StringBuilder sb = new StringBuilder();
    SoftReference<StringBuilder> sbRef = new SoftReference<>(sb);
    sb = null;
    ```

    在上述代码段中，我们为 StringBuilder 对象创建了两个引用。第一行创建了强引用 sb，第二行创建了软引用 sbRef。第三行应该使该对象有资格被收集，但垃圾收集器会因为 sbRef 而推迟收集。

    只有当内存变得紧张，JVM 处于抛出 OutOfMemory 错误的边缘时，情况才会发生变化。换句话说，只收集软引用的对象是回收内存的最后手段。

    使用 WeakReference 类也能以类似的方式创建弱引用。当 sb 被设置为空，而 StringBuilder 对象只有一个弱引用时，JVM 的垃圾回收器绝对不会妥协，会在下一个周期立即回收该对象。

    幻象引用(phantom reference)与弱引用类似，只有幻象引用的对象将无需等待就会被收集。不过，幽灵引用会在其对象被收集后立即进入队列。我们可以轮询引用队列，以了解对象被收集的确切时间。

    Q13. 假设我们有一个循环引用（两个对象相互引用）。这对对象是否有资格被垃圾回收，为什么？

    是的，具有循环引用(circular reference)的一对对象可能符合垃圾回收条件。这是因为 Java 的垃圾回收器是如何处理循环引用的。它认为对象是活的，而不是当它们有任何引用时，而是当它们可以从某个垃圾回收根（活线程的局部变量或静态字段）开始，通过浏览对象图而到达时。如果具有循环引用的一对对象无法从任何根目录(root)到达，则认为该对象符合垃圾回收条件。

    Q14. 字符串在内存中如何表示？

    Java 中的字符串实例是一个具有两个字段的对象：一个 char[] 值字段和一个 int 哈希字段。值字段是一个字符数组，代表字符串本身，而散列字段包含字符串的散列代码（hashCode），该代码的初始化值为 0，在第一次调用 hashCode() 时计算出来，此后一直缓存在内存中。一个奇怪的边缘情况是，如果字符串的 hashCode 值为零，那么每次调用 hashCode() 时都必须重新计算该值。

    重要的是，字符串实例是不可变的：你无法获取或修改底层的 char[] 数组。字符串的另一个特点是，静态常量字符串会在字符串池中加载和缓存。如果源代码中有多个相同的字符串对象，它们在运行时都由一个实例来表示。

    Q15. 什么是字符串生成器？向 Stringbuilder 追加字符串与使用 + 运算符连接两个字符串有什么区别？Stringbuilder 与 Stringbuffer 有何不同？

    StringBuilder 允许通过追加、删除和插入字符和字符串来操作字符序列。这是一种可变的数据结构，而 String 类是不可变的。

    在连接两个 String 实例时，会创建一个新对象，并复制字符串。如果我们需要在循环中创建或修改字符串，这可能会带来巨大的垃圾回收器开销。StringBuilder 可以更高效地处理字符串操作。

    StringBuffer 与 StringBuilder 的不同之处在于它是线程安全的。如果需要在单线程中操作字符串，请使用 StringBuilder。

3. 结论

    在本文中，我们介绍了 Java 工程师面试中经常出现的一些最常见问题。有关内存管理的问题主要是针对高级 Java 开发人员应聘者提出的，因为面试官希望您已经构建了非同小可的应用程序，而这些应用程序很多时候都会受到内存问题的困扰。

## 相关文章

- Java Collections Interview Questions
• Java Type System Interview Questions
• Java Concurrency Interview Questions (+ Answers)
• Java Class Structure and Initialization Interview Questions
• Java 8 Interview Questions(+ Answers)
- [Memory Management in Java Interview Questions (+Answers)](https://www.baeldung.com/java-memory-management-interview-questions)
• Java Generics Interview Questions (+Answers)
• Java Flow Control Interview Questions (+ Answers)
• Java Exceptions Interview Questions (+ Answers)
• Java Annotations Interview Questions (+ Answers)
• Top Spring Framework Interview Questions