# [用Lombok在Spring中注入构造函数](https://www.baeldung.com/spring-injection-lombok)

1. 简介

    Lombok是一个非常有用的库，可以克服模板代码。如果你还不熟悉它，我强烈建议你看一下之前的教程--[Project Lombok简介](https://www.baeldung.com/intro-to-project-lombok)。

    在这篇文章中，我们将展示它与Spring的基于构造函数的依赖注入相结合时的可用性。

2. 基于构造函数的依赖注入

    在Spring中使用基于构造函数的依赖注入是一个很好的方法。这种方法迫使我们明确地将组件的依赖关系传递给构造器。

    相对于基于字段的依赖注入，它还提供了一些优势：

    - 不需要创建一个特定于测试的配置组件 - 依赖关系在构造函数中被明确注入
    - 一致的设计--所有需要的依赖都被强调，并由构造函数的定义来照顾。
    - 简单的单元测试 - 减少Spring框架的开销
    - 重获使用最终关键字的自由

    然而，由于需要编写一个构造函数，这将导致代码库明显增大。考虑一下GreetingService和FarewellService这两个例子：

    ```java
    @Component
    public class GreetingService {

        @Autowired
        private Translator translator;

        public String produce() {
            return translator.translate("hello");
        }
    }

    @Component
    public class FarewellService {

        private final Translator translator;

        public FarewellService(Translator translator) {
            this.translator = translator;
        }

        public String produce() {
            return translator.translate("bye");
        }
    }
    ```

    基本上，这两个组件都做了同样的事情--它们用一个特定的任务词调用一个可配置的翻译器。

    不过，第二种变体更加混乱，因为构造器的模板并没有真正给代码带来任何价值。

    在最新的Spring版本中，它的构造器不需要用@Autowired注解来注解。

3. 使用Lombok的构造函数注入

    使用Lombok，可以为所有类的字段（使用@AllArgsConstructor）或所有最终类的字段（使用@RequiredArgsConstructor）生成一个构造函数。此外，如果你仍然需要一个空的构造函数，你可以附加一个额外的@NoArgsConstructor注解。

    让我们创建第三个组件，与前两个类似：

    lombok/ThankingService.java

    ```java
    @Component
    @RequiredArgsConstructor
    public class ThankingService {

        private final Translator translator;

        public String produce() {
            return translator.translate("thank you");
        }
    }
    ```

    上面的注解将使Lombok为我们生成一个构造函数：

    ```java
    @Component
    public class ThankingService {

        private final Translator translator;

        public String thank() {
            return translator.translate("thank you");
        }

        /* Generated by Lombok */
        public ThankingService(Translator translator) {
            this.translator = translator;
        }
    }
    ```

4. 多个构造函数

    只要一个组件中只有一个构造函数，并且Spring可以明确地选择它作为实例化新对象的正确构造函数，就不必对其进行注释。一旦有了更多的构造函数，你还需要对IoC容器使用的构造函数进行注解。

    考虑一下ApologizeService的例子：这里IoC容器使用的构造函数为 ApologizeService()

    lombok/ApologizeService.java

    ```java
    @Component
    @RequiredArgsConstructor
    public class ApologizeService {

        private final Translator translator;
        private final String message;

        @Autowired
        public ApologizeService(Translator translator) {
            this(translator, "sorry");
        }

        public String produce() {
            return translator.translate(message);
        }
    }
    ```

    上述组件可选择配置的消息字段在组件创建后不能改变（因此没有setter）。因此，它要求我们提供两个构造函数--一个具有完整的配置，另一个具有隐含的、默认的消息值。

    除非其中一个构造函数带有@Autowired、@Inject或@Resource的注释，否则Spring会抛出一个错误：

    `Failed to instantiate [...]: No default constructor found;`

    如果我们想给Lombok生成的构造函数加注，我们就必须用@AllArgsConstructor的onConstructor参数来传递注解：

    ```java
    @Component
    @RequiredArgsConstructor(onConstructor = @__(@Autowired))
    public class ApologizeService {
        // ...
    }
    ```

    onConstructor参数接受一个注释数组（或者像这个特定例子中的单个注释），这些注释将被放在生成的构造函数上。由于向后兼容的问题，我们引入了双下划线的习惯用语。根据文档的内容：

    > 之所以采用这种奇怪的语法，是为了让这个功能在javac 7编译器中发挥作用；`@__` 类型是对注解类型 __（双下划线）的注解引用，而这个类型实际上并不存在；这使得javac 7延迟因错误而中止编译过程，因为有可能一个注解处理器后来会创建__类型。

5. 总结

    在本教程中，我们展示了在增加模板代码方面，没有必要倾向于基于字段的DI而不是基于构造函数的DI。

    感谢Lombok，它可以在不影响运行时性能的情况下自动生成普通代码，将长而不明显的代码缩写为使用单行注释。
