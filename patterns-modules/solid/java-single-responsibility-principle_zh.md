# [Java 中的单一责任原则](https://www.baeldung.com/java-single-responsibility-principle)

1. 概述

    在本教程中，我们将讨论作为面向对象编程 SOLID 原则之一的单一责任原则。

    总的来说，我们将深入探讨什么是该原则，以及在设计软件时如何实现该原则。此外，我们还将解释该原则何时会产生误导。

    *SRP = 单一责任原则

2. 单一责任原则

    顾名思义，该原则规定每个类都应承担一个责任，只有一个目的。这意味着一个类只做一件事，因此我们得出结论，它应该只有一个改变的理由。

    我们不希望我们的对象知道的太多，而行为却互不相关。这些类更难维护。例如，如果我们经常出于不同的原因更改一个类，那么这个类就应该分解成更多的类，每个类处理一个问题。当然，如果出现错误，也会更容易找到。

    让我们考虑一个包含以某种方式更改文本的代码的类。这个类的唯一工作应该是操作文本。

    main/.s/TextManipulator.java

    ```java
    public class TextManipulator {
        ...
        public void printText() {
            System.out.println(textManipulator.getText());
        }
    }
    ```

    虽然这看起来很好，但它并不是一个很好的 SRP 示例。在这里，我们有两项职责：操作和打印文本。

    在该类中使用打印文本的方法违反了单一责任原则。为此，我们应该创建另一个类，只处理打印文本：

    main/.s/TextPrinter.java

    现在，我们可以在这个类中创建各种方法来打印文本，因为这是它的工作。

3. 这一原则怎么会产生误导？

    在软件中实现 SRP 的诀窍在于了解每个类的职责。

    然而，每个开发人员对类的目的都有自己的看法，这让事情变得棘手。由于我们没有关于如何实施这一原则的严格说明，因此我们只能根据自己的理解来确定责任。

    这意味着，有时只有作为应用程序设计者的我们才能决定某件事是否属于类的范围。

    根据 SRP 原则编写类时，我们必须考虑问题领域、业务需求和应用程序架构。这是很主观的，因此实施这一原则比想象的要难。它不会像本教程中的示例那么简单。

    这就引出了下一点。

4. 内聚

    根据 SRP 原则，我们的类将只具有一种功能。它们的方法和数据都有一个明确的目的。这意味着[高内聚性](https://www.baeldung.com/cs/cohesion-vs-coupling)和健壮性，它们共同减少了错误。

    在根据 SRP 原则设计软件时，内聚性至关重要，因为它能帮助我们为类找到单一的职责。这一概念还能帮助我们找到具有多个职责的类。

    让我们回到 TextManipulator 类的方法：

    在这里，我们可以清楚地看到该类的功能：文本操作。

    但是，如果我们不考虑内聚力的问题，也没有明确定义这个班级的职责，我们就可以说，撰写和更新文本是两个不同的、独立的工作。在这种想法的引导下，我们可以得出结论：这应该是两个独立的类： WriteText 和 UpdateText。

    实际上，我们会得到两个紧密耦合和松散内聚的类，它们几乎总是应该一起使用。这三个方法可能会执行不同的操作，但它们本质上都是为了一个目的：文本操作。关键是不要想太多。

    LCOM 是帮助实现方法高度内聚的工具之一。从本质上讲，LCOM 衡量的是类组件之间的联系及其相互关系。

    马丁-希茨（Martin Hitz）和贝扎德-蒙塔泽里（Behzad Montazeri）引入了 [LCOM4](https://www.aivosto.com/project/help/pm-oo-cohesion.html)，[Sonarqube](https://www.baeldung.com/sonar-qube) 曾对其进行过一段时间的度量，但后来已被弃用。

5. 结论

    尽管该原则的名称不言自明，但我们可以看到它是多么容易被错误地执行。在开发项目时，请务必区分每个类的责任，并格外注意内聚性。
