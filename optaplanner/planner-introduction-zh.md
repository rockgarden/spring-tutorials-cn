# OptaPlanner简介

<https://www.optaplanner.org/docs/optaplanner/latest/planner-introduction/planner-introduction.html>

1. 什么是OptaPlanner？

    每个组织都面临规划问题：用有限的受限资源（员工、资产、时间和金钱）提供产品或服务。OptaPlanner优化这种规划，用更少的资源做更多的生意。这就是所谓的约束满足编程（属于运筹学的一部分）。
    OptaPlanner是一个轻量级、可嵌入的约束满足引擎，可以优化规划问题。它解决的用例有：

    - 雇员轮班：为护士、修理工安排时间...。
    - 议程安排：安排会议、约会、维修工作、广告等。
    - 教育时间安排：安排课程、课程、考试、会议演示、......
    - 车辆路线：规划车辆路线（卡车、火车、船、飞机......），以通过多个目的地移动货物和/或乘客，使用已知的地图工具 ...
    - 箱子包装：用物品填充集装箱、卡车、船舶和存储仓库，也可以在计算机资源中包装信息，如在云计算中 ...
    - 工作车间调度：规划汽车装配线，机器排队规划，劳动力任务规划，......
    - 切割库存：在切割纸张、钢铁、地毯时，尽量减少浪费。
    - 运动调度：规划足球联赛、棒球联赛的比赛和训练日程， ...
    - 金融优化：投资组合优化，风险分散， ...

    ![用例综述](/pic/useCaseOverview.png)
2. 什么是规划问题？
    ![什么是规划问题](/pic/whatIsAPlanningProblem.png)

    一个规划问题有一个最佳目标，基于有限的资源和特定的约束条件。最佳目标可以是任何数量的东西，如：：

    - Maximized profits 利润最大化--最佳目标会带来尽可能高的利润。
    - Minimized ecological footprint 生态足迹最小化--最优目标对环境的影响最小。
    - 员工或客户的满意度最大化--最优目标优先考虑员工或客户的需求。

    实现这些目标的能力依赖于可用的资源数量，例如：

    - 人的数量。
    - 时间的数量。
    - 预算。
    - 有形资产，例如，机器、车辆、计算机、建筑物等。
    还必须考虑到与这些资源有关的具体限制，如一个人的工作时间，他们使用某些机器的能力，或设备之间的兼容性。

    OptaPlanner帮助JavaTM程序员有效地解决约束条件的满足问题。在引擎盖下，它将优化启发式方法和元启发式方法与非常有效的分数计算相结合。

    1. 一个规划问题是NP-完整的或NP-困难的

        上面所有的用例都可能是 NP-complete/NP-hard，用通俗的话说就是：

        - 在合理的时间内验证一个问题的给定解是很容易的。
        - 没有银弹(silver bullet)可以在合理(reasonable)的时间内找到一个问题的最优解 (*)。

        > Note
        (*) 至少，世界上最聪明的计算机科学家都还没有找到这样的银弹。但是，如果他们为1个NP-完全问题找到了一个，那么它将对每个NP-完全问题都有效。
        事实上，如果有人能证明这样的[银弹](https://en.wikipedia.org/wiki/P_%3D_NP_problem)是否真的存在，将有100万美元的奖励。

        这意味着非常可怕：解决你的问题可能比你预期的要难，因为两种常见的技术是不够的：

        - 蛮力算法（即使是更聪明的变种）将花费太长时间。
        - 快速算法，例如在垃圾箱包装中，先放入最大的物品，将返回一个远非最佳的解决方案。

        通过使用先进的优化算法，OptaPlanner确实能在合理的时间内为这类规划问题找到一个接近最优的解决方案。

    2. 规划问题有（硬和软）约束
        通常情况下，一个规划问题至少有两层约束：
        - 一个（负的）硬约束不能被打破。例如：1名教师不能在同一时间教授2个不同的课程。
        - 如果可以避免的话，一个（负）软约束不应该被打破。比如说： 教师A不喜欢在周五下午授课。

        有些问题也有积极的约束：
        - 如果可能的话，一个积极的软约束（或奖励）应该被满足。比如说： 教师B喜欢在周一上午授课。

        一些基本问题（如N个皇后）只有硬约束。有些问题有三个或更多层次的约束，例如硬约束、中约束和软约束(constraints)。
        这些约束条件定义了规划问题的分数计算（又称健身函数AKA fitness function）。规划问题的每个解决方案都可以用分数来分级。使用OptaPlanner，分数约束是用面向对象的语言编写的，如JavaTM代码。这种代码简单、灵活、可扩展。

    3. 一个规划问题有一个巨大的搜索空间
        一个规划问题有很多的解决方案。有几类解决方案：

        - 一个可能的解决方案是任何解决方案，无论它是否打破了任何数量的约束。规划问题往往有大量的可能解决方案。这些解决方案中的许多都是没有价值的。
        - 一个可行的解决方案是一个不破坏任何（负）硬约束的解决方案。可行方案的数量往往是相对于可能方案的数量而言的。有时并没有可行的解决方案。每个可行的解决方案都是一个可能的解决方案。
        - 一个最优解是一个具有最高分的解。规划问题往往有一个或几个最优解。即使在没有可行方案和最优方案不可行的情况下，也总是至少有一个最优方案。
        - 找到的最佳解决方案是指在给定的时间内，一个实施方案找到的得分最高的解决方案。找到的最佳解决方案很可能是可行的，而且，只要有足够的时间，它就是一个最佳解决方案。

        反过来说，可能的解决方案的数量是巨大的（如果计算正确的话），即使有一个小的数据集。正如你在例子中看到的，大多数实例的可能解决方案比已知宇宙中的最小原子数（10^80）多得多。因为没有银弹可以找到最佳解决方案，所以任何实施都不得不评估所有这些可能解决方案的至少一个子集。
        OptaPlanner支持几种优化算法，以有效地处理大量可能的解决方案。根据不同的使用情况，一些优化算法比其他算法表现更好，但这是不可能提前知道的。有了OptaPlanner，通过改变几行XML或代码中的求解器配置，很容易切换优化算法。
3. 要求
    OptaPlanner是开源软件，以Apache许可证2.0发布。这个许可证是非常自由的，允许为商业目的重新使用。
    OptaPlanner是100%纯JavaTM，在Java 11或更高版本上运行。它非常容易与其他JavaTM技术整合。OptaPlanner在Maven中心仓库中可用。
    OptaPlanner可在任何Java虚拟机上运行，与主要JVM语言和所有主要平台兼容。

    ![兼容性](/pic/compatibility.png)
4. 治理
    1. OptaPlanner的现状
        OptaPlanner是稳定、可靠和可扩展的。它已经通过单元、集成和压力测试进行了大量的测试，并在世界各地被用于生产。一个例子是处理超过50000个变量，每个变量有5000个值，多种约束类型和数十亿可能的约束匹配。

    2. 向后兼容
        OptaPlanner将其API和实现分开：

        - 公共API： 包命名空间org.optaplanner.core.api、org.optaplanner.benchmark.api、org.optaplanner.test.api和org.optaplanner.persistence...api中的所有类在未来版本（尤其是次要和热修复版本）中100%向下兼容。在极少数情况下，如果主要的版本号发生变化，一些特定的类可能会有一些向后不兼容的变化，但这些都会在升级配方中明确记录下来。
        - XML配置： XML求解器配置对所有元素都是向后兼容的，除了需要使用非公共API类的元素。XML求解器配置是由包命名空间org.optaplanner.core.config和org.optaplanner.benchmark.config中的类定义。
        - 实现类： 所有其他类都是不向后兼容的。它们会在未来的主要或次要版本中发生变化（但可能不会在热修复版本中发生）。升级秘诀描述了每一个这样的相关变化，以及在升级到新版本时如何快速处理。

        > NOTE: 这个文档也涵盖了一些植入类。那些被记录下来的植入类是可靠的，可以安全使用的（除非在本文档中明确标注为实验性的），只是我们还不能完全放心地把它们的签名写在石头上。

    3. 与KIE的关系
        OptaPlanner是[KIE项目组](http://www.kiegroup.org/)的一部分。它定期（通常每3周）一起发布。
        参见[架构概述](https://www.optaplanner.org/docs/optaplanner/latest/optimization-algorithms/optimization-algorithms.html#architectureOverview)，了解更多关于与Drools的可选集成。
